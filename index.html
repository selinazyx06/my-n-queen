<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>N皇后问题可视化</title>
    <style>
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .controls {
            margin-bottom: 20px;
        }
        
        .board {
            display: inline-block;
            border: 2px solid #333;
            margin: 10px;
        }
        
        .row {
            display: flex;
        }
        
        .cell {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            transition: background-color 0.3s;
        }
        
        .cell.white { background-color: #fff; }
        .cell.black { background-color: #ddd; }
        .cell.queen { color: red; }
        .cell.checking { background-color: #ffeb3b; }
        
        .solutions-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
        }

        .dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            z-index: 1000;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>N皇后问题可视化</h1>
        <div class="controls">
            <button id="startBtn">开始新游戏</button>
        </div>
        <div id="solutionsContainer" class="solutions-container"></div>
    </div>

    <script>
        class QueensSolver {
            constructor(n) {
                this.n = n;
                this.board = Array(n).fill().map(() => Array(n).fill('.'));
                this.solutions = [];
            }

            solve() {
                this.backtrack(0);
                return this.solutions;
            }

            isValid(row, col) {
                for (let i = 0; i < row; i++) {
                    if (this.board[i][col] === 'Q') return false;
                }
                
                for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
                    if (this.board[i][j] === 'Q') return false;
                }
                
                for (let i = row - 1, j = col + 1; i >= 0 && j < this.n; i--, j++) {
                    if (this.board[i][j] === 'Q') return false;
                }
                
                return true;
            }

            backtrack(row) {
                if (row === this.n) {
                    this.solutions.push(this.board.map(row => [...row]));
                    return;
                }
                
                for (let col = 0; col < this.n; col++) {
                    if (this.isValid(row, col)) {
                        this.board[row][col] = 'Q';
                        this.backtrack(row + 1);
                        this.board[row][col] = '.';
                    }
                }
            }
        }

        function showDialog(message, buttons) {
            return new Promise(resolve => {
                const overlay = document.createElement('div');
                overlay.className = 'overlay';
                
                const dialog = document.createElement('div');
                dialog.className = 'dialog';
                dialog.innerHTML = `
                    <p>${message}</p>
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        ${buttons.map(btn => `
                            <button>${btn}</button>
                        `).join('')}
                    </div>
                `;

                document.body.appendChild(overlay);
                document.body.appendChild(dialog);

                dialog.addEventListener('click', e => {
                    if (e.target.tagName === 'BUTTON') {
                        overlay.remove();
                        dialog.remove();
                        resolve(e.target.textContent);
                    }
                });
            });
        }

        function showPromptDialog(message, defaultValue = '') {
            return new Promise(resolve => {
                const result = prompt(message, defaultValue);
                resolve(result);
            });
        }

        function createBoard(n, solution) {
            const board = document.createElement('div');
            board.className = 'board';
            
            for (let i = 0; i < n; i++) {
                const row = document.createElement('div');
                row.className = 'row';
                for (let j = 0; j < n; j++) {
                    const cell = document.createElement('div');
                    cell.className = `cell ${(i + j) % 2 ? 'black' : 'white'}`;
                    if (solution[i][j] === 'Q') {
                        cell.textContent = '♕';
                        cell.classList.add('queen');
                    }
                    row.appendChild(cell);
                }
                board.appendChild(row);
            }
            return board;
        }

        async function displaySolutions(solutions, start, end, delay) {
            const container = document.getElementById('solutionsContainer');
            container.innerHTML = '';
            
            for (let i = start; i <= end; i++) {
                const board = createBoard(solutions[0].length, solutions[i-1]);
                const wrapper = document.createElement('div');
                wrapper.innerHTML = `<div style="text-align: center">解法 ${i}</div>`;
                wrapper.appendChild(board);
                container.appendChild(wrapper);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }

        async function startGame() {
            while (true) {
                // 获取N的值
                const nStr = await showPromptDialog('请输入N的值 (1-8)：');
                const n = parseInt(nStr);

                if (isNaN(n) || n < 1) {
                    await showDialog('请输入有效的数字！', ['确定']);
                    continue;
                }

                if (n > 8) {
                    await showDialog('N的值不能大于8！', ['确定']);
                    continue;
                }

                // 求解
                const solver = new QueensSolver(n);
                const solutions = solver.solve();

                if (solutions.length === 0) {
                    const choice = await showDialog(
                        '无解！是否重新开始？',
                        ['重新开始', '结束程序']
                    );
                    if (choice === '结束程序') {
                        return;
                    }
                    continue;
                }

                // 有解的情况
                const choice = await showDialog(
                    `找到 ${solutions.length} 个解！请选择显示方式：`,
                    ['显示单个解', '显示部分解', '显示全部解']
                );

                if (choice === '显示单个解') {
                    const index = await showPromptDialog(`请输入要显示的解法编号 (1-${solutions.length})：`);
                    const num = parseInt(index);
                    if (num >= 1 && num <= solutions.length) {
                        await displaySolutions(solutions, num, num, 3000);
                    }
                }
                else if (choice === '显示部分解') {
                    const range = await showPromptDialog(`请输入范围 (如: 3-10，最大为${solutions.length})：`);
                    const [start, end] = range.split('-').map(Number);
                    if (start >= 1 && end <= solutions.length && start <= end) {
                        const delay = Math.max(500, 3000 / (end - start + 1));
                        await displaySolutions(solutions, start, end, delay);
                    }
                }
                else if (choice === '显示全部解') {
                    await displaySolutions(solutions, 1, solutions.length, 500);
                }

                const playAgain = await showDialog('是否继续？', ['继续', '结束']);
                if (playAgain === '结束') {
                    break;
                }
            }
        }

        document.getElementById('startBtn').addEventListener('click', startGame);
        // ... 其他代码保持不变 ...

async function startGame() {
    while (true) {
        // 获取N的值
        const nStr = await showPromptDialog('请输入N的值 (1-8)：');
        const n = parseInt(nStr);

        if (isNaN(n) || n < 1) {
            alert('请输入有效的数字！');
            continue;
        }

        if (n > 8) {
            alert('N的值不能大于8！');
            continue;
        }

        // 求解
        const solver = new QueensSolver(n);
        const solutions = solver.solve();

        // 添加消息框提示解的情况
        if (solutions.length === 0) {
            alert(`${n}皇后问题无解！`);
            const choice = await showDialog(
                '是否重新开始？',
                ['重新开始', '结束程序']
            );
            if (choice === '结束程序') {
                return;
            }
            continue;
        } else {
            alert(`${n}皇后问题有解！\n共找到 ${solutions.length} 个解法。`);
        }

        // 有解的情况
        const choice = await showDialog(
            `请选择显示方式：`,
            ['显示单个解', '显示部分解', '显示全部解']
        );

        if (choice === '显示单个解') {
            const index = await showPromptDialog(
                `请输入要显示的解法编号 (1-${solutions.length})：\n当前共有${solutions.length}个解`
            );
            const num = parseInt(index);
            if (num >= 1 && num <= solutions.length) {
                await displaySolutions(solutions, num, num, 3000);
            } else {
                alert('输入的编号无效！');
                continue;
            }
        }
        else if (choice === '显示部分解') {
            const range = await showPromptDialog(
                `请输入范围 (如: 3-10)\n当前共有${solutions.length}个解，范围应在1-${solutions.length}之间`
            );
            const [start, end] = range.split('-').map(Number);
            if (start >= 1 && end <= solutions.length && start <= end) {
                const delay = Math.max(500, 3000 / (end - start + 1));
                await displaySolutions(solutions, start, end, delay);
            } else {
                alert('输入的范围无效！');
                continue;
            }
        }
        else if (choice === '显示全部解') {
            await displaySolutions(solutions, 1, solutions.length, 500);
        }

        const playAgain = await showDialog(
            '是否继续尝试其他N值？', 
            ['继续', '结束']
        );
        if (playAgain === '结束') {
            break;
        }
    }
}

// 优化显示解法的函数，添加更多提示信息
async function displaySolutions(solutions, start, end, delay) {
    const container = document.getElementById('solutionsContainer');
    container.innerHTML = '';
    
    const totalSolutions = solutions.length;
    const header = document.createElement('div');
    header.innerHTML = `
        <h2>当前显示第 ${start} 到第 ${end} 个解</h2>
        <p>共有 ${totalSolutions} 个解法</p>
    `;
    container.appendChild(header);
    
    for (let i = start; i <= end; i++) {
        const board = createBoard(solutions[0].length, solutions[i-1]);
        const wrapper = document.createElement('div');
        wrapper.innerHTML = `<div style="text-align: center">解法 ${i} / ${totalSolutions}</div>`;
        wrapper.appendChild(board);
        container.appendChild(wrapper);
        await new Promise(resolve => setTimeout(resolve, delay));
    }
}
// ... 其他代码保持不变 ...

async function calculateDelay(start, end, totalSolutions) {
    // 单个解：3-5秒随机延迟
    if (start === end) {
        return Math.random() * 2000 + 3000; // 3000-5000ms
    }
    
    // 全部解：0.5秒或更快
    if (end - start + 1 === totalSolutions) {
        return Math.min(500, 500 / (totalSolutions / 20)); // 最快可达到100ms
    }
    
    // 部分解：根据数量动态计算，介于0.5秒和3秒之间
    const count = end - start + 1;
    const ratio = count / totalSolutions;
    return Math.max(500, Math.min(3000, 3000 * (1 - ratio)));
}

async function displaySolutions(solutions, start, end) {
    const container = document.getElementById('solutionsContainer');
    container.innerHTML = '';
    
    const totalSolutions = solutions.length;
    const delay = await calculateDelay(start, end, totalSolutions);
    
    // 显示头部信息
    const header = document.createElement('div');
    header.innerHTML = `
        <h2>当前显示第 ${start} 到第 ${end} 个解</h2>
        <p>共有 ${totalSolutions} 个解法</p>
        <p>当前动画延迟: ${(delay/1000).toFixed(1)}秒</p>
    `;
    container.appendChild(header);

    // 如果是单个解，显示详细的放置过程
    if (start === end) {
        const solution = solutions[start-1];
        const board = createEmptyBoard(solution.length);
        container.appendChild(board);
        
        // 逐个显示皇后的放置过程
        for (let row = 0; row < solution.length; row++) {
            for (let col = 0; col < solution.length; col++) {
                if (solution[row][col] === 'Q') {
                    await new Promise(resolve => setTimeout(resolve, delay));
                    placeQueen(board, row, col);
                }
            }
        }
    } 
    // 显示多个解
    else {
        for (let i = start; i <= end; i++) {
            const board = createBoard(solutions[i-1].length, solutions[i-1]);
            const wrapper = document.createElement('div');
            wrapper.innerHTML = `<div style="text-align: center">解法 ${i} / ${totalSolutions}</div>`;
            wrapper.appendChild(board);
            container.appendChild(wrapper);
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
}

function createEmptyBoard(n) {
    const board = document.createElement('div');
    board.className = 'board';
    
    for (let i = 0; i < n; i++) {
        const row = document.createElement('div');
        row.className = 'row';
        for (let j = 0; j < n; j++) {
            const cell = document.createElement('div');
            cell.className = `cell ${(i + j) % 2 ? 'black' : 'white'}`;
            cell.dataset.row = i;
            cell.dataset.col = j;
            row.appendChild(cell);
        }
        board.appendChild(row);
    }
    return board;
}

function placeQueen(board, row, col) {
    const cell = board.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    cell.textContent = '♕';
    cell.classList.add('queen');
    
    // 添加放置效果
    cell.style.animation = 'placeQueen 0.5s ease-out';
}

// 添加CSS动画
const style = document.createElement('style');
style.textContent = `
    @keyframes placeQueen {
        0% {
            transform: scale(0);
            opacity: 0;
        }
        50% {
            transform: scale(1.2);
        }
        100% {
            transform: scale(1);
            opacity: 1;
        }
    }
    
    .queen {
        color: red;
        font-size: 30px;
    }
`;
document.head.appendChild(style);

// 修改主流程中的调用
async function startGame() {
    // ... 前面的代码保持不变 ...

    if (choice === '显示单个解') {
        const index = await showPromptDialog(
            `请输入要显示的解法编号 (1-${solutions.length})：\n当前共有${solutions.length}个解`
        );
        const num = parseInt(index);
        if (num >= 1 && num <= solutions.length) {
            await displaySolutions(solutions, num, num);
        } else {
            alert('输入的编号无效！');
            continue;
        }
    }
    else if (choice === '显示部分解') {
        const range = await showPromptDialog(
            `请输入范围 (如: 3-10)\n当前共有${solutions.length}个解，范围应在1-${solutions.length}之间`
        );
        const [start, end] = range.split('-').map(Number);
        if (start >= 1 && end <= solutions.length && start <= end) {
            await displaySolutions(solutions, start, end);
        } else {
            alert('输入的范围无效！');
            continue;
        }
    }
    else if (choice === '显示全部解') {
        await displaySolutions(solutions, 1, solutions.length);
    }

    // ... 后面的代码保持不变 ...
}
// ... 其他代码保持不变 ...
    </script>
</body>
</html>
